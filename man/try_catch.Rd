% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnd-handlers.R
\name{try_catch}
\alias{try_catch}
\title{Try an expression with condition handlers}
\usage{
try_catch(expr, ...)
}
\arguments{
\item{expr}{An R expression.}

\item{...}{<\code{\link[=dyn-dots]{dynamic-dots}}> Named condition
handlers. The names specify the condition class for which a
handler will be called.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\code{try_catch()} establishes handlers for conditions of a given class
(\code{"error"}, \code{"warning"}, \code{"message"}, ...). Handlers are functions
that take a condition object as argument and are called when the
corresponding condition class has been signalled.

A condition handler can:
\itemize{
\item \emph{Recover from conditions}* with a value. In this case the computation of
\code{expr} is aborted and the recovery value is returned from
\code{try_catch()}. Error recovery is useful when you don't want
errors to abruptly interrupt your program but resume at the
catching site instead.\preformatted{# Recover with the value 0
try_catch(1 + "", error = function(cnd) 0)
}
\item \strong{Rethrow conditions}, e.g. using \code{abort(msg, parent = cnd)}.
See the \code{parent} argument of \code{\link[=abort]{abort()}}. This is typically done to
add information to low-level errors about the high-level context
in which they occurred.\preformatted{try_catch(1 + "", error = function(cnd) abort("Failed.", parent = cnd))
}
\item \strong{Inspect conditions}, for instance to log data about warnings
or errors. In this case, the handler must return the \code{\link[=zap]{zap()}}
sentinel to instruct \code{try_catch()} to ignore (or zap) that
particular handler. The next matching handler is called if any,
and errors bubble up to the user if no handler remains.\preformatted{log <- NULL
try_catch(1 + "", error = function(cnd) \{
  log <<- cnd
  zap()
\})
}
}
}
\section{Stack overflows}{


A stack overflow occurs when a program keeps adding to itself until
the stack memory (whose size is very limited unlike heap memory) is
exhausted.\preformatted{# A function that calls itself indefinitely causes stack overflows
f <- function() f()
f()
#> Error: C stack usage  9525680 is too close to the limit
}

Because \code{try_catch()} preserves as much of the running program as
possible in order to produce informative backtraces on error
rethrows, it is unable to deal with stack overflows. When an
overflow occurs, R needs to unwind as much of the program as is
possible and can't afford to run any more R code, such as in an
error handler.

This usually isn't a problem for error rethrowing or logging but
might make your program more brittle in case of error recovery. In
that case, capture errors with \code{\link[base:conditions]{base::tryCatch()}} instead of
\code{try_catch()}.
}

\section{Comparison with \code{tryCatch()}}{


\code{try_catch()} generalises \code{tryCatch()} and \code{withCallingHandlers()}
in a single function. It reproduces the behaviour of both calling
and exiting handlers depending the on the return value of the
handler. If the handler returns the \code{\link[=zap]{zap()}} sentinel, it is taken
as a calling handler that declines to recover from a condition.
Otherwise, it is taken as an exiting handler which returns a value
from the catching site.

The important difference between \code{tryCatch()} and \code{try_catch()} is
that the program in \code{expr} is still fully running when an error
handler is called. Because the call stack is preserved, this makes
it possible to capture a full backtrace from within the handler,
e.g. when rethrowing the error with \code{abort(parent = cnd)}.
Technically, \code{try_catch()} is more similar to (and implemented on
top of) \code{\link[base:conditions]{base::withCallingHandlers()}} than \verb{tryCatch().}
}

