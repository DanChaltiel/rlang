% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnd-handlers.R
\name{try_catch}
\alias{try_catch}
\title{Try an expression with condition handlers}
\usage{
try_catch(expr, ...)
}
\arguments{
\item{expr}{An R expression.}

\item{...}{<\code{\link[=dyn-dots]{dynamic-dots}}> Named condition
handlers. The names specify the condition class for which a
handler will be called.

Handler functions must have at least two arguments. By
convention, the second argument should be named \code{throw}.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\code{try_catch()} establishes handlers for conditions of a given class
(\code{"error"} \code{"warning"}, \code{"message"}, ...). Handlers are functions
that take a condition object as argument and are called when the
corresponding condition class has been signalled.

A condition handler can:
\itemize{
\item \emph{Recover from conditions}* with a value. In this case the computation of
\code{expr} is aborted and the recovery value is returned from
\code{try_catch()}. Error recovery is useful when you don't want
errors to abruptly interrupt your program but resume at the
catching site instead.
}\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Recover with the value 0
try_catch(1 + "", error = function(cnd) 0)
}\if{html}{\out{</div>}}\preformatted{## [1] 0
}
\itemize{
\item \strong{Rethrow conditions}, e.g. using \code{abort(msg, parent = cnd)}.
See the \code{parent} argument of \code{\link[=abort]{abort()}}. This is typically done to
add information to low-level errors about the high-level context
in which they occurred.
}\if{html}{\out{<div class="sourceCode r">}}\preformatted{try_catch(1 + "", error = function(cnd) abort("Failed.", parent = cnd))
}\if{html}{\out{</div>}}\preformatted{## Error: Failed.
}
\itemize{
\item \strong{Inspect conditions}, for instance to log data about warnings
or errors. In this case, the handler must return the \code{\link[=zap]{zap()}}
sentinel to instruct \code{tryCatch()} to ignore (or zap) that
particular handler. The next matching handler is called if any,
and errors bubble up to the user if no handler remains.
}\if{html}{\out{<div class="sourceCode r">}}\preformatted{log <- NULL
try_catch(1 + "", error = function(cnd) \{
  log <<- cnd
  zap()
\})
}\if{html}{\out{</div>}}\preformatted{## Error in 1 + "": non-numeric argument to binary operator
}
}
\section{Stack overflows}{


A stack overflow occurs when a program keeps adding to itself until
the stack memory (whose size is very limited unlike heap memory) is
exhausted.\preformatted{# A function that calls itself indefinitely causes stack overflows
f <- function() f()
f()
#> Error: C stack usage  9525680 is too close to the limit
}

Because \code{try_catch()} preserves as much of the running program as
possible in order to produce informative backtraces on error
rethrows, it is unable to deal with stack overflows. When an
overflow occurs, R needs to unwind as much of the program is
possible and can't afford to run any more R code, such as in an
error handler.

This usually isn't a problem for error rethrowing or logging but
might make your program more brittle in case of error recovery. In
that case, capture errors with \code{\link[base:conditions]{base::tryCatch()}} instead of
\code{try_catch()}.
}

\section{Comparison with \code{tryCatch()}}{


\code{try_catch()} generalises \code{tryCatch()} and \code{withCallingHandlers()}
in a single function. It reproduces the behaviour of both calling
and exiting handlers depending the on the return value of the
handler. If the handler returns the \code{\link[=zap]{zap()}} sentinel, it is taken
as a calling handler that declines to recover from a condition.
Otherwise, it is taken as an exiting handler which returns a value
from the catching site.

There is an important difference between \code{tryCatch()} and
\code{try_catch()}. The latter doesn't catch condition objects, instead
it catches recovery values returned by the handler. The main
consequence is that the program is still fully running when an
error handler is called. This makes it possible to capture a full
backtrace for the error, e.g. when rethrowing the error with
\code{abort(parent = cnd)}. Technically, \code{try_catch()} is more similar
to (and implemented on top of) \code{\link[base:conditions]{base::withCallingHandlers()}} than
\verb{tryCatch().}

A big downside to keeping the call stack alive when handlers are run
is that stack overflow can't be handled with \code{try_catch()}.
}

