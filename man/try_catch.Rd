% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnd-handlers.R
\name{try_catch}
\alias{try_catch}
\title{Try an expression with condition handlers}
\usage{
try_catch(expr, ...)
}
\arguments{
\item{expr}{An R expression.}

\item{...}{<\code{\link[=dyn-dots]{dynamic-dots}}> Named condition
handlers. The names specify the condition class for which a
handler will be called.

Handler functions must have at least two arguments. By
convention, the second argument should be named \code{throw}.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

\code{try_catch()} establishes handlers for conditions of a given class
(\code{"error"} \code{"warning"}, \code{"message"}, ...). Handlers are functions
that take a condition object as first argument and a throw function
as second argument.\if{html}{\out{<div class="sourceCode r">}}\preformatted{# A prototype of error handler that does not do anything
try_catch(1 + "", error = function(cnd, throw) \{ NULL \})
}\if{html}{\out{</div>}}\preformatted{## Error in 1 + "": non-numeric argument to binary operator
}

A condition handler can:
\itemize{
\item Interrupt the computation of \code{expr} and return from \code{try_catch()}
by calling \code{throw} (the second argument) with a recovery value.
This is useful when you don't want errors to abruptly interrupt
your program but resume at the catching site instead.
\item Rethrow errors using \code{abort(msg, parent = cnd)}. See the \code{parent}
argument of \code{\link[=abort]{abort()}}. This is typically done to add information
to low-level errors about the high-level context in which they
occurred.
\item Inspect the condition object, for instance to log data about
warnings or errors.
}\if{html}{\out{<div class="sourceCode r">}}\preformatted{# An error handler that throws a recovery value
try_catch(1 + "", error = function(cnd, throw) throw(0))
}\if{html}{\out{</div>}}\preformatted{## [1] 0
}\if{html}{\out{<div class="sourceCode r">}}\preformatted{# An error handler that rethrows the error with a different message
try_catch(1 + "", error = function(cnd, throw) abort("Failed.", parent = cnd))
}\if{html}{\out{</div>}}\preformatted{## Error: Failed.
}

Unlike \code{tryCatch()} and \code{try} / \code{catch} constructs in other
programming languages, \code{try_catch()} does not catch
conditions. Instead, it catches \emph{recovery values}. See the
comparison sections below.
}
\section{Throwing versus returning}{


\code{try_catch()} calls matching condition handlers in a loop and
discards any results. Implicit and explicit \code{return()} values have
no effect. To return from \code{try_catch()} with a value, you must
throw it with the function passed as second argument. This causes a
long return that shortcircuits the \code{expr} computation that is still
running when the handler is run.
}

\section{Comparison with \code{tryCatch()}}{


\code{try_catch()} is similar to \code{\link[base:conditions]{base::tryCatch()}} but with important
differences.
\itemize{
\item It doesn't catch condition objects, instead it catches recovery
values thrown with \code{throw()}. The main consequence of this is
that the program is still fully running when an error handler is
called. This makes it possible to capture a full backtrace for
the error, e.g. when rethrowing the error with \code{abort(parent = cnd)}. Technically, \code{try_catch()} is more similar to (and
implemented on top of) \code{\link[base:conditions]{base::withCallingHandlers()}} than
\verb{tryCatch().}
\item Condition handlers are passed two arguments instead of one. The
second argument is a throwing function that allows the handler to
manually stop the current computation and resume with a recovery
value at the catching site. By comparison, \code{tryCatch()} handlers
don't need to explicitly throw a value since \code{expr} is fully
stopped by \code{tryCatch()} before calling the condition handler.
}
}

