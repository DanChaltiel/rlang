% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lifecycle-retired.R
\name{call_standardise}
\alias{call_standardise}
\title{Standardise a call}
\usage{
call_standardise(
  call,
  env = caller_env(),
  ...,
  defaults = FALSE,
  dots_env = empty_env()
)
}
\arguments{
\item{call}{Can be a call or a quosure that wraps a call.}

\item{env}{The environment where to find the definition of the
function quoted in \code{call} in case \code{call} is not wrapped in a
quosure.}

\item{...}{These dots must be empty.}

\item{defaults}{Whether to match missing arguments to their
defaults.}

\item{dots_env}{An execution environment where to find dots. If
supplied and dots exist in this environment, and if \code{call}
includes \code{...}, the forwarded dots are matched to numbered dots
(e.g. \code{..1}, \code{..2}, etc). By default this is set to the empty
environment which means that \code{...} expands to nothing.}
}
\value{
A quosure if \code{call} is a quosure, a raw call otherwise.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}}

Deprecated in rlang 0.4.11 in favour of \code{\link[=call_match]{call_match()}}.
\code{call_standardise()} was designed for call wrappers that include an
environment like formulas or quosures. The function definition was
plucked from that environment. However in practice it is rare to
use it with wrapped calls, and then it's easy to forget to supply
the environment. For these reasons, we have designed \code{\link[=call_match]{call_match()}}
as a simpler wrapper around \code{\link[=match.call]{match.call()}}.

This is essentially equivalent to \code{\link[base:match.call]{base::match.call()}}, but with
experimental handling of primitive functions.
}
