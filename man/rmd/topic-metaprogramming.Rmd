```{r, child = "setup.Rmd", include = FALSE}
```

The patterns covered in this article rely on _metaprogramming_ the ability of creating, defusing, and expanding R expressions. A good place to start if you're new to programming on the language is the [Metaprogramming chapter](https://adv-r.hadley.nz/metaprogramming.html) of the advanced R book.

If you haven't already, read the [data mask programming patterns topic][topic-data-mask-programming] which covers simpler patterns that do not require as much theory to get up to speed.


# Forwarding patterns

## Defuse and inject

[`{{`][embrace-operator] and `...` are sufficient for most purposes. Sometimes however, it is necessary to decompose the forwarding action into its two constitutive steps, [defusing][topic-defuse] and [injecting][topic-inject].

`{{` is the combination of [enquo()] and [`!!`][injection-operator]. These functions are completely equivalent:

```r
my_summarise <- function(data, var) {
  data %>% dplyr::summarise({{ var }})
}
my_summarise <- function(data, var) {
  data %>% dplyr::summarise(!!enquo(var))
}
```

Passing `...` is equivalent to the combination of [enquos()] and [`!!!`][splice-operator]:

```r
my_group_by <- function(.data, ...) {
  .data %>% dplyr::group_by(...)
}
my_group_by <- function(.data, ...) {
  .data %>% dplyr::group_by(!!!enquos(...))
}
```

The advantage of decomposing the steps is that you gain access to the [defused expressions][topic-defuse]. Once defused, you can inspect or modify the expressions before injecting them in their target context.


## Inspecting input labels

For instance, here is how to create an automatic name for a defused argument using [as_label()]:

```{r, comment = "#>", collapse = TRUE}
f <- function(var) {
  var <- enquo(var)
  as_label(var)
}

f(cyl)

f(1 + 1)
```

This is essentially equivalent to formatting an argument using [englue()]:

```{r}
f2 <- function(var) {
  englue("{{ var }}")
}

f2(1 + 1)
```

With multiple arguments, use the plural variant [enquos()]. Set `.named` to `TRUE` to automatically call [as_label()] on the inputs for which the user has not provided a name (the same behaviour as in most dplyr verbs):

```{r, comment = "#>", collapse = TRUE}
g <- function(...) {
  vars <- enquos(..., .named = TRUE)
  names(vars)
}

g(cyl, 1 + 1)
```

Just like with `dplyr::mutate()`, the user can override automatic names by supplying an explicit name:

```{r, comment = "#>", collapse = TRUE}
g(foo = cyl, bar = 1 + 1)
```

More complicated defuse-and-inject patterns are explored in the Transformation patterns section.


# Names patterns

## Symbolise and inject

The symbolise-and-inject pattern is a fallback names pattern for cases where `across(all_of())` is not supported. It consists in creating [defused expressions][topic-defuse] that refer to the data-variables represented in the names vector. These are then injected in the data mask context.

You can symbolise a character vector with [syms()] or [data_syms()]. Simple symbols returned by `syms()` work in a wider variety of cases (e.g. with base functions) but we'll use `data_syms()` as it is more robust (see [Data mask ambiguity][topic-data-mask-ambiguity]). It creates calls that subset the [`.data`] pronoun. Compare:

```{r, comment = "#>", collapse = TRUE}
vars <- c("cyl", "am")

syms(vars)

data_syms(vars)
```

A list of symbols can be injected in data-masked dots with the splice operator [`!!!`][splice-operator], which injects each element of the list as a separate argument:

```r
my_group_by <- function(data, vars) {
  data %>% dplyr::group_by(!!!data_syms(vars))
}

my_group_by(vars)
```

In more complex case, you might want to add R code around the symbols. This requires _transformation_ patterns, see the section below.


# Bridge patterns

## `mutate()` as a data-mask to selection bridge

This is a variant of the `transmute()` bridge pattern described in [Programming patterns][topic-data-mask-programming] that does not materialise `...` in the intermediate step. Instead, the `...` expressions are defused and inspected. Then the expressions, rather than the columns, are spliced in `mutate()`.

```r
my_pivot_longer <- function(data, ...) {
  # Forward `...` in data-mask context with `transmute()`
  # and save the inputs names
  inputs <- dplyr::transmute(data, ...)
  names <- names(inputs)
  
  # Update the data with the inputs
  data <- dplyr::mutate(data, !!!inputs)

  # Select the inputs by name with `all_of()`
  tidyr::pivot_longer(data, cols = all_of(names))
}

mtcars %>% my_pivot_longer(cyl, am = am * 100)
```

1. In a first step we pass the `...` expressions to `transmute()`. Unlike `mutate()`, it creates a new data frame from the user inputs. The only goal of this step is to inspect the names in `...`, including the default names created for unnamed arguments.

2. Once we have the names, we inject the argument expressions into `mutate()` to update the data frame.

3. Finally, we pass the names to the tidy selection via [`all_of()`](https://tidyselect.r-lib.org/reference/all_of.html).


# Transformation patterns

## Transforming inputs manually

If `across()` and variants are not available, you will need to transform the inputs yourself using metaprogramming techniques. To illustrate the technique we'll reimplement `my_mean()` and `filter_non_baseline()` without using `across()` or `if_all()`. The pattern consists in defusing the input expression, building larger calls around them, and finally inject the modified expressions inside the data-masked functions.

We'll start with a single named argument for simplicity:

```{r, comment = "#>", collapse = TRUE}
my_mean <- function(data, var) {
  # Defuse the expression
  var <- enquo(var)

  # Wrap it in a call to `mean()`
  var <- expr(mean(!!var, na.rm = TRUE))

  # Inject the expanded expression
  data %>% dplyr::summarise(mean = !!var)
}

mtcars %>% my_mean(cyl)
```

The `...` technique is similar but a little more involved. We'll use the plural variants `enquos()` and `!!!`. We'll also loop over the variable number of inputs using `purrr::map()`. But the pattern is basically the same:

```{r, comment = "#>", collapse = TRUE}
my_mean <- function(.data, ...) {
  # Defuse the dots. Make sure they are automatically named.
  vars <- enquos(..., .named = TRUE)

  # Map over each defused expression and wrap it in a call to `mean()`
  vars <- purrr::map(vars, ~ expr(mean(!!.x, na.rm = TRUE)))

  # Inject the expressions
  .data %>% dplyr::summarise(!!!vars)
}

mtcars %>% my_mean(cyl)
```

Note that we are inheriting the data-masked behaviour of `summarise()` because we have effectively forwarded `...` inside that verb. This is different than transformation patterns based on `across()` which inherits tidy selection behaviour. For instance, this makes it possible to create new vectors on the fly:

```{r, comment = "#>", collapse = TRUE}
mtcars %>% my_mean(cyl = cyl * 100)
```


# Base patterns

These other patterns are used for programming with base data-masking functions. They essentially consists in building and evaluating expressions in the data mask. In this section, we review and compare these patterns with rlang idioms.


## Data-masked `get()`

In the simplest version of this pattern, `get()` is called with a variable name to retrieve objects from the data mask:

```{r, comment = "#>", collapse = TRUE}
var <- "cyl"

with(mtcars, mean(get(var)))
```

This sort of pattern is susceptible to names collisions. For instance, the input data frame might contain a variable called `var`:

```{r, comment = "#>", collapse = TRUE, error = TRUE}
df <- data.frame(var = "wrong")

with(df, mean(get(var)))
```

To avoid this you can inject [symbols][sym]. Enable injection operators with [inject()]:

```{r, comment = "#>", collapse = TRUE}
inject(
  with(mtcars, mean(!!sym(var)))
)
```

See [The data mask ambiguity][topic-data-mask-ambiguity] for more information about this problem.


## Data-masked `parse()` and `eval()`

A more involved pattern consists in building R code in a string and evaluating it in the mask:

```{r, comment = "#>", collapse = TRUE}
var1 <- "am"
var2 <- "vs"

code <- paste(var1, "==", var2)
with(mtcars, mean(eval(parse(text = code))))
```

As before, the `code` variable is vulnerable to [names collisions][topic-data-mask-ambiguity]. More importantly, if `var1` and `var2` are user inputs, they could contain [adversarial code](https://xkcd.com/327/). Evaluating code assembled from strings is always a risky business:

```r
var1 <- "(function() {
  Sys.sleep(Inf)  # Could be a coin mining routine
})()"
var2 <- "vs"

code <- paste(var1, "==", var2)
with(mtcars, mean(eval(parse(text = code))))
```

This is not a big deal if your code is only used internally. However, this code could be part of a public Shiny app which Internet users could exploit. But even internally, parsing is a source of bugs when variable names contain syntactic symbols like `-` or `:`.

```{r, comment = "#>", collapse = TRUE, error = TRUE}
var1 <- ":var:"
var2 <- "vs"

code <- paste(var1, "==", var2)
with(mtcars, mean(eval(parse(text = code))))
```

For these reasons, always prefer to _build_ code instead of parsing code.

```{r, comment = "#>", collapse = TRUE, error = TRUE}
var1 <- "(function() {
  Sys.sleep(Inf)  # Could be a coin mining routine
})()"
var2 <- "vs"

code <- call("==", sym(var1), sym(var2))
with(mtcars, mean(eval(code)))
```

It is also better to inject the code instead of evaluating it. This avoids names collisions:

```{r, comment = "#>", collapse = TRUE}
var1 <- "am"
var2 <- "vs"

code <- call("==", sym(var1), sym(var2))
inject(
  with(mtcars, mean(!!code))
)
```
