% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/topic-nse.R
\name{topic-defuse}
\alias{topic-defuse}
\alias{quotation}
\alias{nse-defuse}
\title{Defusing R expressions}
\description{
When a piece of R code is defused, R doesn't return its value like
it normally would. Instead it returns the expression in a special
tree-like object that describes how to compute a value. These
defused expressions can be thought of as blueprints or recipes for
computing values.\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Return the result of `1 + 1`
1 + 1
#> [1] 2

# Return the expression `1 + 1`
expr(1 + 1)
#> 1 + 1

# Return the expression and evaluate it
e <- expr(1 + 1)
eval(e)
#> [1] 2
}\if{html}{\out{</div>}}

There are two main ways to defuse expressions, to which correspond
the two rlang functions \code{\link[=expr]{expr()}} and \code{\link[=enquo]{enquo()}}:
\itemize{
\item You can defuse your \emph{own} R expressions with \code{expr()}.
\item You can defuse the expressions supplied by \emph{the user} of your
function with the \code{en}-prefixed operators, such as \code{enquo()} and
\code{enquos()}. These operators defuse function arguments.
}

One purpose for defusing evaluation of an expression is to
interface with \link[=topic-data-masking]{data-masking functions} with
the \link[=howto-defuse-and-inject]{defuse-and-inject pattern}. Function
arguments referring to data-variables are defused and then injected
with \verb{!!} or \verb{!!!} in a data-masking function where the
data-variables are defined.\if{html}{\out{<div class="sourceCode r">}}\preformatted{my_summarise <- function(data, arg) \{
  # Defuse the user expression in `arg`
  arg <- enquo(arg)

  # Inject the expression contained in `arg`
  # inside a `summarise()` argument
  data |> dplyr::summarise(mean = mean(!!arg, na.rm = TRUE))
\}
}\if{html}{\out{</div>}}

This defuse-and-inject pattern is usually performed in a single
step with the \link[=embrace-operator]{embracing operator} \verb{\{\{}.\if{html}{\out{<div class="sourceCode r">}}\preformatted{my_summarise <- function(data, arg) \{
  # Defuse and inject in a single step with the embracing operator
  data |> dplyr::summarise(mean = mean(\{\{ arg \}\}, na.rm = TRUE))
\}
}\if{html}{\out{</div>}}

Using \code{enquo()} and \verb{!!} separately is useful for more complex
cases where you need access to the defused expression instead of
just passing it on.
}
\section{Defused arguments and quosures}{


If you inspect the return values of \code{expr()} and \code{enquo()}, you'll
notice that the latter doesn't return a raw expression like the
former. Instead it returns a \link{quosure}, a wrapper containing an
expression and an environment.\if{html}{\out{<div class="sourceCode r">}}\preformatted{expr(1 + 1)
#> 1 + 1

my_function <- function(arg) enquo(arg)
my_function(1 + 1)
#> <quosure>
#> expr: ^1 + 1
#> env:  global
}\if{html}{\out{</div>}}

R needs information about the environment to properly evaluate
argument expressions because they come from a different context
than the current function. For instance when a function in your
package calls \code{dplyr::mutate()}, the quosure environment indicates
where all the private functions of your package are defined.

Read more about the role of quosures in \link[=topic-quosure]{What are quosures and when are they needed?}.
}

\section{Comparison with base R}{


Defusing is known as \emph{quoting} in other frameworks.
\itemize{
\item The equivalent of \code{expr()} is \code{\link[base:bquote]{base::bquote()}}.
\item The equivalent of \code{enquo()} is \code{\link[base:substitute]{base::substitute()}}. The latter
returns a naked expression instead of a quosure.
\item There is no equivalent for \code{enquos(...)} but you can defuse dots
as a list of naked expressions with \code{eval(substitute(alist(...)))}.
}

What makes tidy eval work consistently and safely is that defused
argument expressions are wrapped in a \link{quosure}. Unlike a naked
expression, a quosure carries information about the context from
which an expression comes from. A quosure is evaluated in the
original environment of the expression, which allows R to find
local data and local functions.
}

\section{Types of defused expressions}{

\itemize{
\item \strong{Calls}, like \code{f(1, 2, 3)} or \code{1 + 1} represent the action of
calling a function to compute a new value, such as a vector.
\item \strong{Symbols}, like \code{x} or \code{df}, represent named objects. When the
object pointed to by the symbol was defined in a function or in
the global environment, we call it an environment-variable. When
the object is a column in a data frame, we call it a
data-variable.
\item \strong{Constants}, like \code{1} or \code{NULL}.
}

You can create new call or symbol objects by using the defusing
function \code{expr()}:\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Create a symbol representing objects called `foo`
expr(foo)
#> foo

# Create a call representing the computation of the mean of `foo`
expr(mean(foo, na.rm = TRUE))
#> mean(foo, na.rm = TRUE)

# Return a constant
expr(1)
#> [1] 1

expr(NULL)
#> NULL
}\if{html}{\out{</div>}}

Defusing is not the only way to create defused expressions. You can
also assemble them from data:\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Assemble a symbol from a string
var <- "foo"
sym(var)

# Assemble a call from strings, symbols, and constants
call("mean", sym(var), na.rm = TRUE)
}\if{html}{\out{</div>}}
}

